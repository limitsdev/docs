---
title: "Policies"
description: "Evaluate policies with check(), evaluate(), and guard()"
---

For `check`, `evaluate`, and `guard` you pass a single identifier (one string per call). It can be:

- **Policy key** — a single policy key, e.g. `'amount-minimum-usd'`
- **Tag** — the tag name with a `#` prefix, e.g. `'#payments'`. All policies with that tag are evaluated; their results are combined into one outcome.

**When using a tag, the strictest result wins:** BLOCK → ESCALATE → ALLOW. If any policy blocks, the decision is block; otherwise if any escalates, the decision is escalate; otherwise allow.

---

## `check(policyKeyOrTag, input)` — conditions

Evaluates a **conditions** policy. `input` must be an object (e.g. request/response data).

**Signature**

```typescript
async check(
  policyKeyOrTag: string,
  input: Record<string, unknown>
): Promise<PolicyEvaluationResult>
```

| Parameter         | Type                    | Required | Description |
|-------------------|-------------------------|----------|-------------|
| `policyKeyOrTag`  | `string`                | **Yes**  | Policy key (e.g. `'amount-minimum-usd'`) or tag (e.g. `'#payments'`). |
| `input`           | `Record<string, unknown>` | **Yes**  | Request/response data object. |

**Returns:** `Promise<PolicyEvaluationResult>`. See [Result shape](#result-shape) below.

**Throws:** `InvalidPolicyKeyError`, `InvalidInputError`, `APIRequestError`, `NetworkError`, `TimeoutError`.

```typescript
const decision = await limits.check('amount-minimum-usd', { amount: 500, currency: 'USD' });
// or by tag:
const decision = await limits.check('#payments', { amount: 500, currency: 'USD' });

if (decision.isBlocked) console.error(decision.data.reason);
else if (decision.isEscalated) console.warn(decision.data.reason);
else console.log('Allowed:', decision.data.reason);
```

---

## `evaluate(policyKeyOrTag, prompt, response)` — instructions

Evaluates an **instructions** policy (prompt + LLM response). Typically used in **middleware** to validate LLM outputs before returning them.

**Signature**

```typescript
async evaluate(
  policyKeyOrTag: string,
  prompt: string,
  response: string
): Promise<PolicyEvaluationResult>
```

| Parameter         | Type     | Required | Description |
|-------------------|----------|----------|-------------|
| `policyKeyOrTag`  | `string` | **Yes**  | Policy key or tag (e.g. `'#refunds'`). |
| `prompt`          | `string` | **Yes**  | User prompt. |
| `response`        | `string` | **Yes**  | LLM response to validate. |

**Returns:** `Promise<PolicyEvaluationResult>`.

```typescript
const decision = await limits.evaluate('refund-policy', userPrompt, llmResponse);
if (decision.isBlocked) { /* handle block */ }
```

---

## `guard(policyKeyOrTag, input)` — guardrails

Evaluates a **guardrails** policy on text. `input` must be a string. Typically used in **middleware** to check model output (e.g. safety, PII) before sending to the user.

**Signature**

```typescript
async guard(
  policyKeyOrTag: string,
  input: string
): Promise<PolicyEvaluationResult>
```

| Parameter         | Type     | Required | Description |
|-------------------|----------|----------|-------------|
| `policyKeyOrTag`  | `string` | **Yes**  | Policy key or tag (e.g. `'#safety'`). |
| `input`           | `string` | **Yes**  | Text to check (e.g. model output). |

**Returns:** `Promise<PolicyEvaluationResult>`.

```typescript
const decision = await limits.guard('content-guardrail', modelOutput);
// or by tag:
const decision = await limits.guard('#safety', modelOutput);
```

---

## Result shape

The API returns a response with `meta` and `result`; the SDK normalizes this to the `PolicyEvaluationResult` shape below. All three methods return a `PolicyEvaluationResult`:

```typescript
{
  data: { action: 'ALLOW' | 'BLOCK' | 'ESCALATE'; reason: string };
  isAllowed: boolean;
  isBlocked: boolean;
  isEscalated: boolean;
  errors?: string[];  // validation errors when present
}
```

| Field          | Type     | Description |
|----------------|----------|-------------|
| `data`         | `object` | Always present. |
| `data.action`  | `'ALLOW' \| 'BLOCK' \| 'ESCALATE'` | Decision. |
| `data.reason`  | `string` | Human-readable reason. |
| `isAllowed`    | `boolean`| `data.action === 'ALLOW'`. |
| `isBlocked`    | `boolean`| `data.action === 'BLOCK'`. |
| `isEscalated`  | `boolean`| `data.action === 'ESCALATE'`. |
| `errors`       | `string[] \| undefined` | Validation errors from the API when present. |

**Example (allowed)**

```json
{
  "data": {
    "action": "ALLOW",
    "reason": "Transaction amount is within allowed limits"
  },
  "isAllowed": true,
  "isBlocked": false,
  "isEscalated": false
}
```

**Example (blocked with validation errors)**

```json
{
  "data": {
    "action": "BLOCK",
    "reason": "Parameter validation failed"
  },
  "isAllowed": false,
  "isBlocked": true,
  "isEscalated": false,
  "errors": [
    "Missing required parameter: 'currency' in request"
  ]
}
```

---

## Error handling

| Error class             | When it is thrown |
|-------------------------|--------------------|
| `InvalidAPIKeyError`    | Key missing or doesn't start with `sk_`. |
| `InvalidPolicyKeyError` | Policy key/tag empty or invalid. |
| `InvalidInputError`     | Empty input where required. |
| `APIRequestError`       | API returned 4xx/5xx (`error.statusCode`, `error.response`). |
| `NetworkError` / `TimeoutError` | Request failed or timed out. |

```typescript
import { Limits, InvalidAPIKeyError, APIRequestError } from '@limits/js';

try {
  const decision = await limits.check('my-policy', { amount: 100 });
  // use decision
} catch (err) {
  if (err instanceof InvalidAPIKeyError) {
    console.error('Invalid or missing API key');
    return;
  }
  if (err instanceof APIRequestError) {
    console.error('API error:', err.statusCode, err.message);
    if (err.statusCode === 404) console.error('Policy not found');
    return;
  }
  throw err;
}
```

---

## Full flow example

```typescript
import { Limits, APIRequestError } from '@limits/js';

const limits = new Limits({ apiKey: process.env.LIMITS_API_KEY! });

async function evaluateTransaction(amount: number, currency: string) {
  try {
    const result = await limits.check('amount-minimum-usd', { amount, currency });

    if (result.isBlocked) {
      console.error('Blocked:', result.data.reason);
      if (result.errors?.length) result.errors.forEach((e) => console.error('  -', e));
      return { allowed: false, reason: result.data.reason };
    }

    if (result.isEscalated) {
      console.warn('Escalated for review:', result.data.reason);
      return { allowed: 'review', reason: result.data.reason };
    }

    return { allowed: true, reason: result.data.reason };
  } catch (e) {
    if (e instanceof APIRequestError) console.error('API error', e.statusCode, e.message);
    throw e;
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Guardrails" icon="shield" href="/sdk/guardrails">
    Use <code>guard()</code> to evaluate text (safety, PII, moderation).
  </Card>
  <Card title="Escalations" icon="user-check" href="/sdk/human-approvals">
    List, approve, and decline escalations.
  </Card>
  <Card title="Platform Policies" icon="layout" href="/platform/policies">
    Create and manage policies in the web interface.
  </Card>
</CardGroup>
